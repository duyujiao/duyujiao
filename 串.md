# 串

### 1.串的定义

**串**是由零个或多个字符组成的有限序列，又名叫字符串。

一般记为s="a1a2······an"(n>=0) s是串的名称，双引号里面是串的值，注意引号不是串的内容，n称为串的长度。

**空串**：零个字符的串，长度为0

**空格串**：只包含空格的串，可以不止一个空格，注意它与空串的区别

**子串与主串**：串中任意个数的连续字符组成的子序列称为该串的子串，相应的，包含字串的串称为主串

子串在主串的**位置**就是子串的第一个字符在主串中的序号

### 2.串的存储结构



串的**顺序**存储结构

```c
#define MAXLEN 255
typedef struct{
    char ch[MAXLEN+1];//存储串的一维数组
    int length;//串的当前长度长度
}SString;
```

串的**链式**存储结构----**块链结构**

```c
#define CHUNKSIZE 80//块的大小可由用户定义
typedef struct Chunk{
    char ch[CHUNKSIZE];
    struct Chunk*next；
}Chunk;
typedef struct{
    Chunk*head,*tail;//串的头指针和尾指针
    int curlen;//串的当前长度
}LString;//字符串的块链结构
```

### 3.朴素的模式匹配算法-BF算法

Index(S,T,pos)

将主串的第pos个字符和模式串的第一个字符比较，

若相等，继续逐个比较后续字符

若不等，从主串的下一个字符起，重新与模式串的第一个字符比较

直到主串的一个连续子串字符序列与模式串相等，返回值为S中与T匹配的子序列第一个字符的序号，即匹配成功。否则匹配失败，返回值0。

```c
int Index_BF(SString S,SString T){
    int i=1,j=1;
    while(i<=S.length&&j<=T.length){
        if(s.ch[i]==t.ch[j]){
            ++i;
            ++j;
        }//主串和子串依次匹配下一个字符
        else{
            i=i-j+2;
            j=1;
        }//主串和子串指针回溯重新开始下一次匹配
    }
        if(j>=T.length)
            return i-T.length;//返回匹配的第一个字符下标
        else
            return 0;//模式匹配不成功
}
```

### 4.广义表

**广义表**通常记作：LS=(a1,a2,...an)

其中：LS为表名，n为表的长度，每一个ai为表的元素

习惯上，一般用大写字母表示广义表，小写字母表示原子

**表头**:若LS非空(n>=1),则其第一个元素a1就是表头

记作head(LS)=a1 注意：表头可以是原子，也可以是子表。

**表尾**：除表头之外的其它元素组成的表

记作 tail(LS)=(a2,...,an) 注意：表尾不是最后一个元素，而是一个子表。
