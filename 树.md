# 树

## 1.树的定义

树（Tree)是n（n>=0)个节点的有限集。

若n=0,称为空树；

若n>0,则它满足如下两个条件：

（1）有且仅有一个特定的称为根的结点

（2）其余结点可分为m（m>=0)个互不相交的有限集T1、T2、...Tm，其中每一个集合本身又是一棵树，并称为根的子树。

**树的定义是一个递归的定义**

## 2.树的基本术语

根结点：非空树中无前驱结点的结点

结点的度：结点拥有的子树的数

度不等于0的结点称为分支结点或非终端结点，除根结点以外的分支结点称为内部结点

度=0的结点称为叶结点或终端结点

树的度：树内各结点的度的最大值

此图这颗树结点的度的最大值是结点D的度，是3,所以树的度为3。（大话数据结构152页）

![](/home/oem/图片/Screenshot-1.png)

**孩子，双亲**：结点的子树的根称为该结点的孩子，该结点称为孩子的双亲（哈哈，对于结点来说父母同体，没有父或母）

**兄弟**：同一个双亲的孩子之间互称为兄弟

结点的**祖先：**从根到该结点所经分支上的所有结点，反之，以某结点为根的子树中的任意结点都称为该结点的**子孙**

例如上图中，B是A的孩子，B和C是兄弟，B是D的双亲，对于H来说D B A都是它的祖先，B的子孙有D G H I

**结点的层次**：从根开始定义起，根为第一层，根的孩子为第二层。其双亲的同一层的结点互为**堂兄弟**

**树的深度/高度**：树中结点的最大层次称为树的深度或高度

例如上图中，D E F是堂兄弟，G H I与J也是堂兄弟，当前树的深度为4

**有序树，无序树**：如果将树中结点的各子树看成从左到右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。

**森林**：森林是m棵互不相交的树的集合

树----一定是------->森林,森林--------不一定---------->是树

| 线性结构                   |
| -------------------------- |
| 第一个数据元素：无前驱     |
| 最后一个数据元素：无后继   |
| 中间元素：一个前驱一个后继 |

| 树结构                     |
| -------------------------- |
| 根结点：无双亲，唯一       |
| 叶结点：无孩子，可以多个   |
| 中间结点：一个双亲多个孩子 |

## 3.二叉树的定义

为什么要研究每个结点最多只有两个“叉”的树？

（1）二叉树的结构最简单，规律性最强

（2）可以证明，所有树都能转化为唯一对应的二叉树，不失一般性

普通树（多叉树）若不转化为二叉树，则运算很难实现！！！

**二叉树**是n个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个**根结点**和**两棵互不相交**的，分别称为根结点的**左子树**和**右子树**的二叉树组成。

**特点**：（1）每个结点最多有两个孩子（二叉树中不存在度大于2的结点）。不是只有两棵子树，而是最多有。没有子树或者有一棵子树都是可以的

（2）子树有左右之分，其次序不能颠倒。就像人是双手，双脚，但显然左手，左脚和右手，右脚是不一样的，右手戴左手套，右脚穿左鞋都会极其别扭和难受

（3）二叉树可以是空集合，根可以有空的左子树或空的右子树，即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。

<font color=red>注意</font>:二叉树不是树的特殊情况，它们是两个概念

树的结点当有一个孩子时，无需区分左右次序。

二叉树具有五种基本形态：

🕐空二叉树

🕑只有一个根结点

🕒根结点只有左子树

🕓根结点只有右子树

🕔根结点既有左子树又有右子树

三个结点会有五种形态。

### 特殊二叉树

**1.斜树**

所有的结点都只有左子树的二叉树叫左斜树，所有的结点都是只有右子树的二叉树叫右斜树，两者统称为斜树。斜树有很明显的特点，就是每一层都只有一个结点，结点的个数与二叉树的深度相同。

**2.满二叉树**

在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。

特点：

（1）叶子只能出现在最下一层，出现在其他层就不可能达成平衡了。

（2）非叶子结点的度一定是2,否则就是缺胳膊少腿了

（3）在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多

**3.完全二叉树**

对一棵具有n个结点的二叉树按层序编号，如果编号为i（1<=i<=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。<font color=red>编号连续</font>

特点：

叶子结点只能出现在最下两层

最下层的叶子一定集中在左部连续位置

倒数第二层，如果有叶子结点，一定都在右部连续位置

如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况。

同样结点树的二叉树，完全二叉树的深度最小

## 4.二叉树的性质

**（1）**在二叉树的第i层上至多有2^（i-1）个结点，第i层至少有一个结点。（i>=1)

其实这个性质很好记忆，观察一下使用数学归纳法证明:

第一层是根结点，只有一个是2^(1-1)=1;

第二层有两个，2^(2-1)=2;

第三层有四个，2^(3-1)=4;

第四层有八个，2^(4-1)=8.

**（2）**深度为k的二叉树至多有(2^k)-1个结点,至少有k个结点

深度为k的意思就是有k层二叉树，

如果有一层，至多有1=（2^1)-1个结点；

如果有两层，至多有1+2=3=（2^2)-1个结点；

如果有三层，至多有1+2+4=7=（2^3)-1个结点；

如果有四层，至多有1+2+4+8=15=（2^4)-1个结点。

**（3）**对于任何一棵二叉树T，如果其终端结点数为n0,度为2的结点数为n2,则n0=n2+1

设度为1的结点数是n1,则总结点数:n=n0+n1+n2

总边数:n-1=n1+2n2,连立即可得出结论。

**（4）**具有n个结点的完全二叉树的深度为[log2n]+1([x]代表不大于x的最大整数)

**（5）**如果对一棵有n个结点的完全二叉树（其深度为[log2n]+1）的结点按层序编号（从第一层到第[log2n]+1层，每层从左到右），对任一结点i（1<=i<=n）有：

1）如果i=1,则结点i是二叉树的根，无双亲；如果i>1，则其双亲是结点[i/2]

2）如果2i>n,则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i

3）如果2i+1>n，则结点i无右孩子，否则其右孩子是结点2i+1

## 5.树的存储结构

### 1.双亲表示法

以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点在数组中的位置

| data | parent |
| ---- | ------ |

data是数据域，存储结点的数据信息，parent是指针域，存储结点的双亲在数组中的下标

约定根结点的位置域为-1，也就是parent为-1

```c
//树的双亲表示法结点结构定义
#define MAX_TREE_SIZE 100
typedef int TElemType;//树结点的数据类型，目前暂定为整形
typedef struct PTNode//结点结构
{
    TElemType data;//结点数据
    int parent;//双亲位置
}PTNode;
typedef struct//树结构
{
    PTNode nodes[MAX_TREE_SIZE];//结点数组
    int r,n;//根的位置和结点数
}PTree;
```

### 2.孩子表示法

每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示法。

160页

| child | next |
| ----- | ---- |

| data | firstchild |
| ---- | ---------- |



```c
//树的孩子表示法结构定义
#define MAX_TREE_SIZE 100
typedef struct CTNode//孩子结点
{
    int child;
    struct CTNode*next;
}*ChildPtr;
typedef struct//表头结构也就是双亲结点结构
{
    TElemType data;//数据元素本身
    ChildPtr firstchild;//指针指向它的第一个孩子
}CTBox;
typedef struct
{
    CTBox nodes[MAX_TREE_SIZE];//结点数组
    int r,n;//根的位置和结点数
}CTree;
```

### 3.孩子兄弟表示法

| data | firstchild | rightsib |
| ---- | ---------- | -------- |

```c
//树的孩子兄弟表示法结构定义
typedef struct CSNode
{
    TElemType data;
    struct CSNode*firstchild,*rightsib;//第一个孩子，兄弟结点
}CSNode,*CSTree;//结点类型，指向结点的指针
```

## 6.二叉树的存储结构

### 1.二叉树的顺序存储结构

二叉树数序存储结构的**缺点**

最坏的情况：深度为k的且只有k个结点的单支树需要长度为（2^k)-1的以一维数组

所以浪费空间，**适用于**存储满二叉树和完全二叉树

### 2.二叉链表

二叉树每个结点最多有两个孩子，所以设计了一个数据域和两个指针域，这样的链表叫做二叉链表

| lchild | data | rchild |
| ------ | ---- | ------ |

data是数据域，lchild,rchild是指针域，分别存放左孩子和右孩子的指针

**递归的实现**

```c
//二叉树的二叉链表结点结构定义
typedef struct BiTNode//结点结构
{
    TElemType data;//数据元素，结点数据
    struct BiTNode*lchild,*rchild;//左右孩子指针
}BiTNode,*BiTree;
```

<font color=red>思考：</font>在n个结点的二叉链表中，有n+1个空指针域

有n个结点，就会有2n个指针域，除过根结点，每个结点有且仅有一个双亲，所以就会有n-1个结点被占着

所以空指针的数目为2n-(n-1)=n+1

## 7.遍历二叉树

二叉树的遍历是指从根结点出发，按照某种**次序**依次**访问**二叉树中所有结点，使得每个结点被访问一次且仅被访问一次

### 1.二叉树的遍历方法及算法

🕐前序遍历（先序遍历）DLR-根左右

```c
void PreOrderTraverse(BiTree T)
{
    if(T==NULL)
        return;
    printf("%c",T->data);//显示结点数据，可以更改为其他对结点操作
    PreOrderTraverse(T->lchild);//再先序遍历左子树
    PreOrderTraverse(T->rchild);//最后先序遍历右子树
}
```

🕑中序遍历LDR-左根右

```c
void PreOrderTraverse(BiTree T)
{
    if(T==NULL)
        return;
    PreOrderTraverse(T->lchild);//中序遍历左子树
    printf("%c",T->data//显示结点数据，可以更改为其他对结点操作
    PreOrderTraverse(T->rchild);//最后中序遍历右子树
}
```

🕒后序遍历LRD-左右根

```c
void PreOrderTraverse(BiTree T)
{
    if(T==NULL)
        return;
    PreOrderTraverse(T->lchild);//先后序遍历左子树
    PreOrderTraverse(T->rchild);//再后序遍历右子树
    printf("%c",T->data);//显示结点数据，可以更改为其他对结点操作
}
```

🕓层序遍历（层次遍历）

得到两个二叉树遍历的性质

已知前序遍历序列和中序遍历序列。可以确定唯一一棵二叉树

已知后序遍历序列和中序遍历序列。可以确定唯一一棵二叉树
